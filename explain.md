```rust
Circuit
- import:ImportItem
    - model:String //导入元件模型的名字
        对应 ComponentModelObject //(对应一个元件.json)
        
- components:Component
- wires:Wire
- blocks:BlockInfo
    porperties: Properties //特殊的方块属性
- inputs:Port
- outputs:Port

```

# 仿真

仿真需要的文件有:

单个元件仿真的情况：
- 元件model.json 就是元件库中的json
- 仿真输入.json 记录了输入端口输入什么样的信号

输出：
- 输出端口信号.json


===



目前元件的仿真是通过在nbt文件里面每个方块的红石能量计算得出的。这样明显非常不好，慢而且复杂。

思路：
1. 元件库中的元件，仿真信息用一个表达式记录在模型文件里：
and.json
```json
...
"sim":{
    "eval":"&"
}
```
这样，仿真的时候，对于可以信赖的元件，就直接通过记录的表达式得出输出。
复杂的电路由简单的元件组成，那么在不考虑红石能量衰减的情况下，直接由简单表达式组合而成即可。
那么就还需要端口之间的连接图。
1. 仿真之前，预先生成一张端口之间的连接关系图。
```json
[
    {
        "from":"a",
        "to":"b",
        "distance":12,
        "reversable":false
    }
]
```
distance通过某种方法得出，考虑到wire的长度以及红石中继器的放置得出的。通过distance，得出两个端口之间是否是红石可达的，以及是否双向可达。不可达的链接，就不会加到逻辑连接关系图。

那么，为了得到这样的物理连接关系图，就需要基于项目文件中的wire和component的端口得出。
在此我们规定：
1. 导线只有两端才是可相连的，两个交叉的导线，如果没有一端在另一个导线上，就不视为相互连接的；
2. 如果一个导线没有将它的首或尾连接到端口，那么这个端口就没有和导线连接。
3. 导线上默认不放置红石中继器

那么，基于这些规则，我们就可以通过遍历所有的导线，得出它们的连接关系，从而得出物理连接关系图。

于是接下来仿真还需要一个输入信号描述文件：
```json
{
    "inputs":{
        "port_id_1":15,
        "port_id_2":15
    }
}
```
输入端口的信号值。

