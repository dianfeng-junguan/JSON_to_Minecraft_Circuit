# 星期二, 七月 08 2025

## Tasks
- 添加检查线路可达性的功能
## Notes

检查方法如下：

将输出输入口，导线相连处（首尾相连，中间相交不算）视作节点，然后每条导线视为有长度的边，成为一个图，然后每个输出口查找不计距离可达的所有输入口，然后遍历这些输入口，计算二者之间的距离，如果超过了红石线最大传播长度，则检查是否有中继器，考虑中继器再推算，如果仍然不可达，就视为不可达。

计算二者距离的方法使用Dijkstra算法，除此之外还要找出两者之间所有的路径。

检查中继器的方法是，遍历所有路径，一步步演绎红石能量，遇到中继器充能，直到终点或者能量耗尽。

添加边的时候还要检查上面有没有中继器，有的话这条边就变成单向边了。

下面定义数据结构：

''' 伪代码

Dot{
    pos:Position,
    distance:i32,//自起点的距离
    type:NodeType,//输入输出等
}
Edge{
    start:Dot,
    end:Dot,
    length:i32,//导线长度
    direct:EdgeDirect,//单向还是双向
}
enum EdgeDirect{
    Bidirectional,
    Reversed,
    Nonreversed
}
enum NodeType{
    Input,
    Output,
    Passby
}
struct Graph{
    Inputs:[&Dot]
    Outputs:[&Dot]
    Nodes:[Dot]
    Edges:[Edge]
    fn get_distance(start:Dot,end:Dot)->i32{
        //Dijkstra算法
    }
    fn get_neighbors(dot:&Dot)->[&Dot]{
        //返回与dot相邻的点
    }
    fn get_reachables(dot:&Dot)->[&Dot]{
        //返回与dot可达的点
    }
    fn get_paths(start:&Dot,end:&Dot)->[Vec<&Dot>]{
        //返回从start到end的所有路径
    }
    fn add_dot...
    fn add_edge...
}
//代码流程
new graph
add dots
add blocks
for w in wires{
    let edge
    for p in w{//检查中继器
        if repeater at p{
            let new_direction=match repeater.direction{
                forward=>EdgeDirect::Nonreversed,
                backward=>EdgeDirect::Reversed,
            }
            if edge.direct.conlicts(new_direction){
                //这条线是不通的
                error!("线路冲突")
            }else{
                edge.direct=new_direction
            }
        }
        edge.length+=1
    }
    add_edge(edge)
}
for d in Outputs{
    let reachables = get_reachables(d);
    for r in reachables{
        let distance = get_distance(d,r);//这里计算距离的时候已经考虑了单向边
        if distance > max_distance{
            let reacheable=false;
            //检查中继器
            let paths = get_paths(d,r);
            for p in paths{
                let mut energy = max_distance;
                for e in p{
                    if repeater at e{
                        energy=max_distance
                    }else{
                        energy-=1
                        if energy<=0{
                            break
                        }
                    }
                }
                if energy>0{
                    //可达
                    reacheable=true
                    break
                }else{
                    //不可达
                }
            }
            if reacheable{
                //可达
            }else{
                //不可达
                error!("线路不可达")
            }
        }
    }
}
error=r{
    println!("Error: {}",r)
    return false;
}
otherwise
return true;

'''

实现的代码：

'''Rust

fn check_circuit(obj: &Circuit, model_objects: &Vec<Box<dyn ModelObject>>) -> bool {
    // 定义数据结构
    #[derive(Debug, Clone)]
    struct Dot {
        pos: Position,
        distance: i32, // 自起点的距离
        type_: NodeType, // 输入输出等
    }

    #[derive(Debug, Clone)]
    struct Edge {
        start: usize,
        end: usize,
        length: i32, // 导线长度
        direct: EdgeDirect, // 单向还是双向
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    enum EdgeDirect {
        Bidirectional,
        Reversed,
        Nonreversed,
    }

    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    enum NodeType {
        Input,
        Output,
    }

    // 构建图
    let mut graph = Graph {
        dots: vec![],
        edges: vec![],
        outputs: vec![],
        inputs: vec![],
    };

    // 添加输入和输出节点
    for &pos in &obj.inputs {
        graph.add_dot(Dot {
            pos,
            distance: i32::MAX,
            type_: NodeType::Input,
        });
    }
    for &comp in &obj.components {
        comp.inputs.iter().for_each(|&pos| {
            graph.add_dot(Dot {
                pos,
                distance: i32::MAX,
                type_: NodeType::Input,
            });
        });
        comp.outputs.iter().for_each(|&pos| {
            graph.add_dot(Dot {
                pos,
                distance: i32::MAX,
                type_: NodeType::Output,
            });
        });
    }

    // 添加导线节点和边
    for wire in &obj.wires {
        let start_idx = graph.find_dot_or_add(wire.start.clone());
        let end_idx = graph.find_dot_or_add(wire.end.clone());
        let mut direct = EdgeDirect::Bidirectional;

        // 检查导线上的中继器
        let positions = wire_positions(&wire.start, &wire.end);
        for pos in positions {
            if let Some(block) = obj.blocks.iter().find(|b| b.position == pos) {
                if block.id == "repeater" {
                    direct = match repeater_direction(&pos, &obj.blocks) {
                        Some(RepeaterDirection::Forward) => EdgeDirect::Nonreversed,
                        Some(RepeaterDirection::Backward) => EdgeDirect::Reversed,
                        None => EdgeDirect::Bidirectional, // 默认双向
                    };
                    break;
                }
            }
        }

        graph.add_edge(Edge {
            start: start_idx,
            end: end_idx,
            length: wire_length(&wire.start, &wire.end),
            direct,
        });
    }

    // 检查可达性
    for output in &obj.outputs {
        let output_idx = graph.find_dot(output.clone()).unwrap();
        let reachables = graph.get_reachables(output_idx);
        for &reachable_idx in &reachables {
            let reachable = &graph.dots[reachable_idx];
            let distance = graph.get_distance(output_idx, reachable_idx);
            if distance > MAX_REDSTONE_DISTANCE {
                let paths = graph.get_paths(output_idx, reachable_idx);
                let mut reachable_with_repeater = false;
                for path in paths {
                    let mut energy = MAX_REDSTONE_DISTANCE;
                    let mut last_dot = output_idx;
                    for &dot_idx in &path {
                        let dot = &graph.dots[dot_idx];
                        if let Some(edge) = graph.find_edge(last_dot, dot_idx) {
                            if edge.direct == EdgeDirect::Reversed {
                                energy = MAX_REDSTONE_DISTANCE;
                            } else if edge.direct == EdgeDirect::Nonreversed {
                                if let Some(block) = obj.blocks.iter().find(|b| b.position == dot.pos) {
                                    if block.id == "repeater" {
                                        energy = MAX_REDSTONE_DISTANCE;
                                    } else {
                                        energy -= edge.length;
                                        if energy <= 0 {
                                            reachable_with_repeater = false;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        last_dot = dot_idx;
                    }
                    if energy > 0 {
                        reachable_with_repeater = true;
                        break;
                    }
                }
                if !reachable_with_repeater {
                    error_begin();
                    println!("Error: 线路不可达: {} -> {}", output, reachable.pos);
                    return false;
                }
            }
        }
    }

    true
}

// 辅助结构体和函数
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum RepeaterDirection {
    Forward,
    Backward,
}

struct Graph {
    dots: Vec<Dot>,
    edges: Vec<Edge>,
    outputs: Vec<&Dot>,
    inputs: Vec<&Dot>,
}

impl Graph {
    fn new() -> Self {
        Graph {
            edges: vec![],
            outputs: vec![],
            inputs: vec![],
            dots: vec![],
        }
    }

    fn add_dot(&mut self, dot: Dot) -> usize {
        let idx = self.dots.len();
        match dot.type_ {
            NodeType::Input => self.inputs.push(&self.dots[idx]),
            NodeType::Output => self.outputs.push(&self.dots[idx]),
            _ => {}
        }
        self.dots.push(dot);
        idx
    }

    fn find_dot(&self, pos: Position) -> Option<usize> {
        self.dots.iter().position(|d| d.pos == pos)
    }

    fn find_dot_or_add(&mut self, pos: Position) -> usize {
        if let Some(idx) = self.find_dot(pos.clone()) {
            idx
        } else {
            self.add_dot(Dot {
                pos,
                distance: i32::MAX,
                type_: NodeType::Input, // 默认为输入
            })
        }
    }

    fn add_edge(&mut self, edge: Edge) {
        self.edges.push(edge);
    }

    fn find_edge(&self, start: usize, end: usize) -> Option<&Edge> {
        self.edges.iter().find(|e| e.start == start && e.end == end)
    }

    fn get_distance(&self, start: usize, end: usize) -> i32 {
        let mut distances = vec![i32::MAX; self.dots.len()];
        let mut visited = vec![false; self.dots.len()];
        distances[start] = 0;

        while let Some((current, current_distance)) = distances.iter().enumerate().filter(|&(_, &dist)| !visited[dist]).min_by_key(|&(_, &dist)| dist) {
            if current == end {
                return current_distance;
            }
            visited[current] = true;
            for edge in &self.edges {
                if edge.start == current {
                    let neighbor_distance = current_distance + edge.length;
                    if neighbor_distance < distances[edge.end] {
                        distances[edge.end] = neighbor_distance;
                    }
                }
            }
        }

        i32::MAX
    }

    fn get_neighbors(&self, dot: usize) -> Vec<usize> {
        self.edges.iter()
            .filter(|e| e.start == dot)
            .map(|e| e.end)
            .collect()
    }

    fn get_reachables(&self, dot: usize) -> Vec<usize> {
        let mut visited = vec![false; self.dots.len()];
        let mut reachables = vec![];
        let mut queue = vec![dot];

        while let Some(current) = queue.pop() {
            if visited[current] {
                continue;
            }
            visited[current] = true;
            reachables.push(current);
            for &neighbor in &self.get_neighbors(current) {
                queue.push(neighbor);
            }
        }

        reachables
    }

    fn get_paths(&self, start: usize, end: usize) -> Vec<Vec<usize>> {
        let mut paths = vec![];
        let mut queue = vec![(start, vec![start])];

        while let Some((current, path)) = queue.pop() {
            if current == end {
                paths.push(path.clone());
            } else {
                for edge in &self.edges {
                    if edge.start == current {
                        let mut new_path = path.clone();
                        new_path.push(edge.end);
                        queue.push((edge.end, new_path));
                    }
                }
            }
        }

        paths
    }
}

fn wire_positions(start: &Position, end: &Position) -> Vec<Position> {
    // 假设导线是直线连接的，这里简单处理为从start到end的所有位置
    let mut positions = vec![];
    let (dx, dy, dz) = (end.x - start.x, end.y - start.y, end.z - start.z);
    let steps = dx.abs().max(dy.abs()).max(dz.abs());

    for i in 0..=steps {
        positions.push(Position {
            x: start.x + dx * i / steps,
            y: start.y + dy * i / steps,
            z: start.z + dz * i / steps,
        });
    }

    positions
}

fn wire_length(start: &Position, end: &Position) -> i32 {
    // 计算曼哈顿距离
    (start.x - end.x).abs() + (start.y - end.y).abs() + (start.z - end.z).abs()
}

fn repeater_direction(pos: &Position, blocks: &Vec<BlockInfo>) -> Option<RepeaterDirection> {
    // 假设中继器的方向存储在NBT中，这里简单处理为从blocks中查找方向
    for block in blocks {
        if block.position == *pos && block.id == "repeater" {
            // 假设中继器的方向存储在某个字段中，这里简单处理为总是向前
            return Some(RepeaterDirection::Forward);
        }
    }

    None
}

const MAX_REDSTONE_DISTANCE: i32 = 15; // 红石的最大传播距离

'''